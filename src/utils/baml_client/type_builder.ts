/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import { FieldType } from '@boundaryml/baml/native'
import { TypeBuilder as _TypeBuilder, EnumBuilder, EnumViewer, ClassBuilder, ClassViewer } from '@boundaryml/baml/type_builder'
import { DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME } from "./globals"

export { FieldType, EnumBuilder, ClassBuilder }

export default class TypeBuilder {
    private tb: _TypeBuilder;
    
    AlertLite: ClassViewer<'AlertLite', "sender_name" | "event" | "start" | "end" | "description" | "tags">;
    
    AnswerLines: ClassViewer<'AnswerLines', "lines">;
    
    CurrentLite: ClassViewer<'CurrentLite', "temperature" | "feels_like" | "conditions" | "humidity" | "pressure" | "wind_speed" | "wind_direction" | "visibility" | "uv_index" | "clouds">;
    
    DailyForecastItem: ClassViewer<'DailyForecastItem', "date" | "summary" | "temperature" | "conditions" | "precipitation_probability" | "rain">;
    
    FormattedWeather: ClassViewer<'FormattedWeather', "location" | "current" | "daily_forecast" | "alerts">;
    
    LocationLite: ClassViewer<'LocationLite', "lat" | "lon" | "timezone">;
    
    MemoryRecall: ClassViewer<'MemoryRecall', "query" | "results">;
    
    NewsItem: ClassViewer<'NewsItem', "title" | "content">;
    
    PlaceLines: ClassViewer<'PlaceLines', "lines">;
    
    PlaceSuggestion: ClassViewer<'PlaceSuggestion', "id" | "name" | "address" | "snippet">;
    
    QueryResult: ClassViewer<'QueryResult', "query" | "results">;
    
    QuestionAnalysisResponse: ClassViewer<'QuestionAnalysisResponse', "original_text" | "has_question" | "question" | "answer">;
    
    RoutingBehavior: ClassViewer<'RoutingBehavior', "origin" | "routing">;
    
    TempBlock: ClassViewer<'TempBlock', "day" | "min" | "max" | "night">;
    
    WeatherConditionLite: ClassViewer<'WeatherConditionLite', "id" | "main" | "description" | "icon">;
    
    WeatherLines: ClassViewer<'WeatherLines', "lines">;
    
    
    Router: EnumViewer<'Router', "WEATHER" | "WEB_SEARCH" | "MAPS" | "KNOWLEDGE" | "MEMORY_INSERTION" | "MEMORY_RECALL">;
    

    constructor() {
        this.tb = new _TypeBuilder({
          classes: new Set([
            "AlertLite","AnswerLines","CurrentLite","DailyForecastItem","FormattedWeather","LocationLite","MemoryRecall","NewsItem","PlaceLines","PlaceSuggestion","QueryResult","QuestionAnalysisResponse","RoutingBehavior","TempBlock","WeatherConditionLite","WeatherLines",
          ]),
          enums: new Set([
            "Router",
          ]),
          runtime: DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME
        });
        
        this.AlertLite = this.tb.classViewer("AlertLite", [
          "sender_name","event","start","end","description","tags",
        ]);
        
        this.AnswerLines = this.tb.classViewer("AnswerLines", [
          "lines",
        ]);
        
        this.CurrentLite = this.tb.classViewer("CurrentLite", [
          "temperature","feels_like","conditions","humidity","pressure","wind_speed","wind_direction","visibility","uv_index","clouds",
        ]);
        
        this.DailyForecastItem = this.tb.classViewer("DailyForecastItem", [
          "date","summary","temperature","conditions","precipitation_probability","rain",
        ]);
        
        this.FormattedWeather = this.tb.classViewer("FormattedWeather", [
          "location","current","daily_forecast","alerts",
        ]);
        
        this.LocationLite = this.tb.classViewer("LocationLite", [
          "lat","lon","timezone",
        ]);
        
        this.MemoryRecall = this.tb.classViewer("MemoryRecall", [
          "query","results",
        ]);
        
        this.NewsItem = this.tb.classViewer("NewsItem", [
          "title","content",
        ]);
        
        this.PlaceLines = this.tb.classViewer("PlaceLines", [
          "lines",
        ]);
        
        this.PlaceSuggestion = this.tb.classViewer("PlaceSuggestion", [
          "id","name","address","snippet",
        ]);
        
        this.QueryResult = this.tb.classViewer("QueryResult", [
          "query","results",
        ]);
        
        this.QuestionAnalysisResponse = this.tb.classViewer("QuestionAnalysisResponse", [
          "original_text","has_question","question","answer",
        ]);
        
        this.RoutingBehavior = this.tb.classViewer("RoutingBehavior", [
          "origin","routing",
        ]);
        
        this.TempBlock = this.tb.classViewer("TempBlock", [
          "day","min","max","night",
        ]);
        
        this.WeatherConditionLite = this.tb.classViewer("WeatherConditionLite", [
          "id","main","description","icon",
        ]);
        
        this.WeatherLines = this.tb.classViewer("WeatherLines", [
          "lines",
        ]);
        
        
        this.Router = this.tb.enumViewer("Router", [
          "WEATHER","WEB_SEARCH","MAPS","KNOWLEDGE","MEMORY_INSERTION","MEMORY_RECALL",
        ]);
        
    }

    reset(): void {
        this.tb.reset();
        // TODO: This should happen in Rust. Problem is, when we construct the
        // typebuilder we instantiate class builders once and it seems to make
        // a JS copy, bypassing the Rust side? In Python however, every time we
        // access a class builder with @property, we get a new instance that
        // wraps over the Rust type builder, so we only need to call tb.reset().
        // In JS it's not possible unless we refactor the way class builders are
        // accessed.
        
    }

    __tb() {
      return this.tb._tb();
    }

    string(): FieldType {
        return this.tb.string()
    }

    literalString(value: string): FieldType {
        return this.tb.literalString(value)
    }

    literalInt(value: number): FieldType {
        return this.tb.literalInt(value)
    }

    literalBool(value: boolean): FieldType {
        return this.tb.literalBool(value)
    }

    int(): FieldType {
        return this.tb.int()
    }

    float(): FieldType {
        return this.tb.float()
    }

    bool(): FieldType {
        return this.tb.bool()
    }

    list(type: FieldType): FieldType {
        return this.tb.list(type)
    }

    null(): FieldType {
        return this.tb.null()
    }

    map(key: FieldType, value: FieldType): FieldType {
        return this.tb.map(key, value)
    }

    union(types: FieldType[]): FieldType {
        return this.tb.union(types)
    }

    addClass<Name extends string>(name: Name): ClassBuilder<Name> {
        return this.tb.addClass(name);
    }

    addEnum<Name extends string>(name: Name): EnumBuilder<Name> {
        return this.tb.addEnum(name);
    }

    addBaml(baml: string): void {
        this.tb.addBaml(baml);
    }
}